{
  "clause_id": "C-INDEX",
  "title": "Index Storage",
  "kind": "normative",
  "status": "active",
  "text": "The search index MUST be stored as a SQLite FTS5 database in the skill's runtime directory.\n\n**Index file naming:**\nTo avoid collisions when multiple source directories share a runtime store, the index file MUST be named using a hash of the source path:\n\n```\n.skillc-meta/search-<hash16>.db\n```\n\nWhere `<hash16>` is the first 16 characters (64 bits) of the SHA-256 hash of the canonicalized source directory path.\n\n**Tokenizer preference:**\nThe current tokenizer preference is determined at runtime:\n1. Attempt `porter unicode61`\n2. If unavailable, fall back to `unicode61`\n\nThis preference is used for both index creation (build) and checking (search).\n\n**Corrupt index definition:**\nAn index is **corrupt** if any of:\n- The database file cannot be opened as a SQLite database\n- The `index_meta` table does not exist\n- Any required key is missing (`skill_path`, `source_hash`, `schema_version`, `tokenizer`)\n- Any required key value cannot be parsed (e.g., non-integer `schema_version`)\n\n**Any read or parse failure during index access MUST be treated as corruption.** Implementations MUST NOT attempt to distinguish transient errors from permanent corruption; all failures map to the same handling (E002 for search, delete+rebuild for build).\n\n**Index file selection (search):**\nWhen searching, the implementation MUST follow these steps in order:\n\n1. Compute the expected filename `search-<hash16>.db`\n2. If file does not exist: exit with error E002 (missing)\n3. Open the database and read required keys from `index_meta`; if corrupt (per definition above): exit with error E002\n4. If `skill_path` does not match current source path: exit with error E003 (collision)\n5. Check staleness conditions (see below): if stale, exit with error E002\n6. Proceed with search\n\n**E002 conditions (search):**\nE002 (\"unusable\") is the umbrella error covering three distinct failure modes:\n- **Missing**: file does not exist (step 2)\n- **Corrupt**: any read/parse failure (step 3)\n- **Stale**: metadata mismatch (step 5) — a subset of \"unusable\"\n\nAll three require `skc build` to fix.\n\nSee [[RFC-0005:C-CODES]] for canonical error messages.\n\n**Staleness conditions (search-only):**\n\"Stale\" is a subset of \"unusable\" that applies when the index can be read but its metadata does not match the current skill state.\n\nAfter confirming no collision (step 4), the index is **stale** if any of:\n- `source_hash` does not match current manifest hash\n- `schema_version` < current schema version (currently `2`)\n- `tokenizer` does not match current tokenizer preference\n\nThese three fields are the only staleness conditions. Missing file and corrupt index are handled earlier (steps 2-3). The `skill_path` field is used for collision detection (step 4), not staleness.\n\nIf stale, `skc search` MUST exit with error E002.\n\n**Index lifecycle (build):**\nWhen `skc build` runs:\n\n1. Compute the expected filename `search-<hash16>.db`\n2. If file does not exist: proceed to step 6 to create new index\n3. Open the database and read required keys from `index_meta`; if any read/parse failure: delete file, proceed to step 6 to create new index\n4. If `skill_path` does NOT match current source path: exit with error E003 (collision). Stop.\n5. Compare `source_hash`, `schema_version`, and `tokenizer`:\n   - **If** all match: skip rebuild. Done.\n   - **Else**: delete existing file, proceed to step 6 to create new index.\n6. **Create new index** with current tokenizer preference\n\nBuild does not error on unusable indexes; it rebuilds them. Corrupt indexes are deleted without collision detection since `skill_path` cannot be reliably read.\n\nBuild behavior summary:\n- **Missing**: create new index (step 2 → 6)\n- **Corrupt**: delete and rebuild without collision check (step 3 → 6)\n- **Collision** (`skill_path` mismatch): error E003 (step 4)\n- **Up-to-date** (all metadata matches): skip rebuild (step 5)\n- **Stale** (metadata differs): rebuild (step 5 → 6)\n\n**No automatic cleanup:**\nThe implementation MUST NOT delete other `search-*.db` files. Multiple skills may share a runtime directory.\n\n**Runtime directory resolution:**\nThe runtime directory MUST be resolved using the same logic as [[RFC-0007:C-RESOLUTION]].\n\n**Index schema:**\nThe database MUST contain a virtual table using FTS5 for full-text search:\n\n```sql\nCREATE VIRTUAL TABLE sections USING fts5(\n    file,\n    section,\n    content,\n    tokenize='porter unicode61'\n);\n```\n\nThe database MUST contain a `headings` table for section lookup by [[RFC-0002:C-SHOW]]:\n\n```sql\nCREATE TABLE headings (\n    id INTEGER PRIMARY KEY,\n    file TEXT NOT NULL,\n    text TEXT NOT NULL,\n    level INTEGER NOT NULL,\n    start_line INTEGER NOT NULL,\n    end_line INTEGER NOT NULL\n);\n\nCREATE INDEX idx_headings_text ON headings(text COLLATE NOCASE);\n```\n\nFields:\n- `file` — relative path from skill root\n- `text` — heading text (without `#` prefix)\n- `level` — heading level (1-6)\n- `start_line` — 1-based line number of heading\n- `end_line` — 1-based line number of next heading (or EOF+1)\n\nThe database MUST also contain a metadata table:\n\n```sql\nCREATE TABLE index_meta (\n    key TEXT PRIMARY KEY,\n    value TEXT\n);\n```\n\n**Required metadata keys:**\n- `source_hash` — Hash from [[RFC-0001:C-MANIFEST]]\n- `skill_path` — Canonicalized absolute path to source directory\n- `schema_version` — Integer (currently `2`)\n- `indexed_at` — RFC 3339 UTC timestamp\n- `tokenizer` — `porter` or `unicode61`\n\n**Schema migration:**\nNo in-place migration. User must run `skc build`.\n\n*Updated in v0.2.0: Added `headings` table for index-based section lookup. Bumped `schema_version` to `2`.*",
  "since": "0.1.0"
}
